# -*- coding: utf-8 -*-

from IO import IO
from CPU import CPU
from Function import Func
from Memory import Memory

if __name__ == "__main__":
    word_len = 32 # 字长
    mem_len = 8 # 内存一个单元的大小
    reg_num = 32 # 寄存器个数
    reg_add_len = 5 #指令中用于寄存器寻址的位数
    
    #Func
    Fun=Func(word_len,mem_len) # 方法类实例
    # Memory
    Mem=Memory(word_len,mem_len)  # 内存实例
    
    # CPU,含32个寄存器、加法器和控制器
    Cpu=CPU(word_len,mem_len,reg_num,Mem,reg_add_len,Fun)  # CPU实例
    Cpu.reg=Cpu.Register(Cpu)  # CPU中寄存器实例
    Cpu.Adder=Cpu.Adder(Cpu)  # CPU中加法器实例
    Cpu.Controller=Cpu.Controller(Cpu,Cpu.reg,Cpu.Adder)  # CPU中控制器实例
    Cpu.Decoder=Cpu.Decoder(Cpu,Cpu.Controller)  # CPU中译码器实例
    
    # I/O
    Io=IO(word_len,Mem,Fun)  # I/O实例
# =============================================================================
# 在内存#1,#2,#3中写入初始化数
# =============================================================================
    Io.write("#1",0)   # 将初始值写入内存
    Io.read("#1")      # 从内存读出初始值
    Io.write("#2",6)   # 将步长写入内存
    Io.read("#2")      # 从内存读出步长
    Io.write("#3",10)  # 将上限值写入内存
 
# =============================================================================
# 在内存中写入程序   
# =============================================================================
             
    # 待存入内存地址#0处的指令：010000/0000 0000 00/101000/00000/00010   JR #10 
    instruction_JR =    [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0]
    
    # 待存入内存地址#10到#17的指令依次为：
    # 011000/00001/0000 0000 0000 0100/00010    load r1,#1———————#10
    # 011000/00010/0000 0000 0000 1000/00010    load r2,#2———————#11
    # 011000/00011/0000 0000 0000 1100/00010    load r3,#3———————#12
    # 001000/00001/00001/00010/000000/00000     Add r1,r1,r2—————#13
    # 001001/00100/00001/00011/000000/00000     SLT r4,r1,r3—————#14
    # 011010/00100/0000 0000 0011 0100/00010    BGT r4,#13———————#15
    # 011001/00001/0000 0000 0000 0100/00010    Store r1,#1——————#16
    # 11111111111111111111111111111111111111    end——————————————#17
    instruction_list = [[0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],
                        [0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0],
                        [0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0],
                        [0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0],
                        [0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]    
    
    
    mem_addlist0 = Fun.MemId_toBlock("#0")  # 由形式地址#0获取该地址对应的4个内存块的物理地址组成的列表  
    Mem.write(mem_addlist0,instruction_JR)  # 将32位的“JR #10”指令存入内存#0处
    
    for i in range(0,8):                    # 将instruction_list中的指令依次存入内存地址#10——#17处
        mem_addlist = Fun.MemId_toBlock("#"+str(10+i))
        Mem.write(mem_addlist,instruction_list[i])
        
        
# =============================================================================
# 运行程序
# =============================================================================
    PC="00000000000000000000000000000000"   # PC初始化为全0
    while True:
        instruction = Mem.read(Func.FirstAddress_toBlock(Fun,PC))
        l = Cpu.Decoder.Decode(instruction)  #l的格式：[第一项，用于标记是否跳转：int型，为0表示不跳转，执行PC+4；为1表示跳转，执行PC=l[1]
                                             #        第二项：string,跳转地址
                                             #        第三项，用于标记是否要结束：int型,为0:continue;为1:break]
        
        if l[0] == 0: #不跳转，执行PC+4（每个指令存在4个内存块中）
            #PC是二进制字符串，先用int(PC,2)转为int型，再+4，再用bin转为二进制字符串，去除二进制字符串前面的“0b”,在字符串左侧补0填满32位
            PC = bin(int(PC,2)+4).replace('0b','').zfill(32)  
        else:  #l[0] == 1,跳转，执行PC=跳转地址L[1]
            PC = l[1]
        if l[2] == 1: #结束条件成立，表示指令存储到内存完毕，退出While循环
            break

    Io.read("#1") # 读取#1中数据           
